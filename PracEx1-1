strings are considered sequences
consider if the sequence is mutable, tuples for example will not be


Given a sequence, swap the first and last element
strings are immutable, must create a copy to avoid those problems

a = [1,2,3,4,5]
tmp = a[0], "variable takes on the value at index pos 0 which is element 1"
a[0] = a[-1] "index pos 0 is switched with last value"
a[-1] = tmp "last index pos is switched with the first value which was assigned to tmp"
a = [5, 2, 3, 4, 1]

Faster way to swap
a[0], a[-1] = a[-1], a[0]

binary
a = 42
bin(a) -> 0b101010
format(a,'#b') -> 0b101010
format(a,'b') -> 101010
0b -> notifys binary literal 
0x -> notifys hexadecimal

format(a,<type>) the type can be specified, for example, b will output the number in binary
                  for type, '#b', for example, will cause another form to take place, adds the prefix to the binary
                  

inverted = 255 - original

#!/usr/bin/env python3

'''list1 = list(range(0,10,1))'''
list1=['100','200','250']`
print(list1)
for item in list1:
    print(list1[item])
    list1[item] = 255 - list1[item]     
    print(list1[item])
print(list1)

**2nd iteration

print(l)
    print(l[0])
    print(type(l[0]))
    counter=0
    for item in l:
        print(l[counter])
        strl=(str(255 - int(l[counter])))
        l[counter] = strl
        counter += 1
    print(l)
    return none
    
    numofelems = len(l)
    indexpos = list(range(0,numofelems,1)
    newlist=[]
    for item in indexpos:
        invertval = str(255 - int(l[indexpos]))
        newlist.append(invertval)
        return newlist
   
   
 ormat(ord(myChar),'0>8b'

charlist=list(format(ord(char),'0>8b'))
for item in cover:
  list(bin(item))

numofelems = len(l)
    indexpos = list(range(0,top,1)
    newlist=[]
    for item in indexpos:
        invertval = str(255 - int(l[indexpos]))
        newlist.append(invertval)
        return newlist
        
        
charlist=list(format(ord(char),'0>8b'))
    counter = 0
    for item in cover:
        numlist=list(bin(item))
        numlist[-1] = charlist[counter]
        ''.join(numlist)
        counter += 1
        
int(<binary>,'2') gets decimal

stegography code!!
charlist=list(format(ord(char),'0>8b'))
    counter = 0
    print(charlist)
    for item in cover:
        numlist=list(format(int(cover[counter]),'b'))
        print(numlist)
        numlist[-1] = charlist[counter]
        print(numlist)
        cover[counter]=str(int(''.join(numlist),base=2))
        print(cover[counter])
        counter += 1
    return(print(cover))

decoder!!

        
        
